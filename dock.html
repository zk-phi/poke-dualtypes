<head>
  <meta charset="utf-8"/>
  <script src="https://cdn.jsdelivr.net/npm/vue@2.7.10"></script>
  <style>
* {
  box-sizing: border-box;
}
body {
  margin: 0;
}
#app {
  display: flex;
  height: 100vh;
}
.column {
  height: 100%;
  overflow-y: scroll;
  padding: 16px;
  border: 1px solid rgba(0, 0, 0, 0.1);
}
.column.glow {
  flex-grow: 2;
}
table {
  border-spacing: 0;
  background: rgba(0, 0, 0, 0.05);
}
tr:first-child, td:first-child {
  font-weight: bold;
}
td {
  border: white 1px solid;
  padding: 4px;
}
  </style>
</head>
<body>
  <div id="app">

    <datalist id="pokemon-names">
      <option v-for="name in pokemonNames" :value="name" />
    </datalist>

    <datalist id="types">
      <option v-for="type in allTypes" :value="type" />
    </datalist>

    <div class="column glow">
      <h2>ポケモン育成支援</h2>

      <p>
        ポケモン：<input list="pokemon-names" v-model="pokemonName">
        {{ this.pokemonNameError ? "🚨" : "👍" }}
      </p>

      <div v-if="!pokemonNameError" class="statuses">
        <p>
          タイプ：{{ types.join(", ") }}（テラスタイプ <input list="types" v-model="teratype" />）
        </p>

        <p>
          <table>
            <tr>
              <td></td>
              <td v-for="type in typeAbbrevs">{{ type }}</td>
            </tr>
            <tr>
              <td>通常</td>
              <td v-for="effectiveness in defEffectiveness"
                  :style="{ backgroundColor: colors[effectiveness] }">
                {{ effectiveness }}
              </td>
            </tr>
            <tr>
              <td>テラス</td>
              <td v-for="type in allTypes"
                  :style="{ backgroundColor: colors[effectiveness[type][teratype]] }">
                {{ effectiveness[type][teratype] }}
              </td>
            </tr>
          </table>
        </p>

        <p>
          <table>
            <tr>
              <td rowspan="6">
                <svg height="256" width="256" viewBox="0, 0, 300, 300">
                  <polygon
                      v-for="polygon in chartPolygons"
                      stroke-width="2"
                      :fill="polygon.fill || 'none'"
                      :stroke="polygon.stroke || 'none'"
                      :points="polygon.points" />
                </svg>
              </td>
              <td>HP</td>
              <td>
                {{ computedStats.h }}
                <span v-if="bonus.h != 1">({{ computedStats.widthBonus.h }})</span>
              </td>
            </tr>
            <tr>
              <td>攻撃</td>
              <td>
                {{ computedStats.a }}
                <span v-if="bonus.a != 1">({{ computedStats.withBonus.a }})</span>
              </td>
            </tr>
            <tr>
              <td>防御</td>
              <td>
                {{ computedStats.b }}
                <span v-if="bonus.b != 1">({{ computedStats.withBonus.b }})</span>
              </td>
            </tr>
            <tr>
              <td>特攻</td>
              <td>
                {{ computedStats.c }}
                <span v-if="bonus.c != 1">({{ computedStats.withBonus.c }})</span>
              </td>
            </tr>
            <tr>
              <td>特防</td>
              <td>
                {{ computedStats.d }}
                <span v-if="bonus.d != 1">({{ computedStats.withBonus.d }})</span>
              </td>
            </tr>
            <tr>
              <td>素早</td>
              <td>
                {{ computedStats.s }}
                <span v-if="bonus.s != 1">({{ computedStats.withBonus.s }})</span>
              </td>
            </tr>
          </table>
          <small>※ 青三角が正三角形のとき効率的な耐久指数 (H=B+D∧B=D) になります</small>
        </p>

        <p>
          <button @click="tab = 'attack'">一括ダメージ計算（物理）</button>
          <button @click="tab = 'special-attack'">一括ダメージ計算（特殊）</button>
          <button @click="tab = 'speed'">素早さ比較</button>
        </p>

        <h3>努力値振り</h3>

        <p>
          lv：<input type="range" v-model="level" min="50" max="100" /> {{ level }}
        </p>

        <table>
          <tr>
            <td></td>
            <td>種族値</td>
            <td>個体値</td>
            <td>努力値</td>
            <td>性格補正</td>
            <td>道具・特性等</td>
            <td>lv{{ level }}実数値</td>
          </tr>
          <tr>
            <td>HP</td>
            <td>{{ stats.h }}</td>
            <td><input type="range" v-model="iv.h" min="0" max="31" step="1">{{ iv.h }}</td>
            <td v-if="autoEv">{{ optStats.ev.h }}</td>
            <td v-else><input type="range" v-model="ev.h" min="0" max="252" step="4">{{ ev.h }}</td>
            <td>-</td>
            <td>x <input type="number" v-model="bonus.h" min="0" max="2" step="0.1"></td>
            <td>
              {{ computedStatsAtLevel.h }}
              <span v-if="bonus.h != 1">({{ computedStatsAtLevel.withBonus.h }})</span>
            </td>
          </tr>
          <tr>
            <td>攻撃</td>
            <td>{{ stats.a }}</td>
            <td><input type="range" v-model="iv.a" min="0" max="31" step="1">{{ iv.a }}</td>
            <td><input type="range" v-model="ev.a" min="0" max="252" step="4">{{ ev.a }}</td>
            <td><input type="range" v-model="n.a" min="0.9" max="1.1" step="0.1">{{ n.a }}</td>
            <td>x <input type="number" v-model="bonus.a" min="0" max="2" step="0.1"></td>
            <td>
              {{ computedStatsAtLevel.a }}
              <span v-if="bonus.a != 1">({{ computedStatsAtLevel.withBonus.a }})</span>
            </td>
          </tr>
          <tr>
            <td>防御</td>
            <td>{{ stats.b }}</td>
            <td><input type="range" v-model="iv.b" min="0" max="31" step="1">{{ iv.b }}</td>
            <td v-if="autoEv">{{ optStats.ev.b }}</td>
            <td v-else><input type="range" v-model="ev.b" min="0" max="252" step="4">{{ ev.b }}</td>
            <td v-if="autoEv">{{ optStats.n.b }}</td>
            <td v-else><input type="range" v-model="n.b" min="0.9" max="1.1" step="0.1">{{ n.b }}</td>
            <td>x <input type="number" v-model="bonus.b" min="0" max="2" step="0.1"></td>
            <td>
              {{ computedStatsAtLevel.b }}
              <span v-if="bonus.b != 1">({{ computedStatsAtLevel.withBonus.b }})</span>
            </td>
          </tr>
          <tr>
            <td>特攻</td>
            <td>{{ stats.c }}</td>
            <td><input type="range" v-model="iv.c" min="0" max="31" step="1">{{ iv.c }}</td>
            <td><input type="range" v-model="ev.c" min="0" max="252" step="4">{{ ev.c }}</td>
            <td><input type="range" v-model="n.c" min="0.9" max="1.1" step="0.1">{{ n.c }}</td>
            <td>x <input type="number" v-model="bonus.c" min="0" max="2" step="0.1"></td>
            <td>
              {{ computedStatsAtLevel.c }}
              <span v-if="bonus.c != 1">({{ computedStatsAtLevel.withBonus.c }})</span>
            </td>
          </tr>
          <tr>
            <td>特防</td>
            <td>{{ stats.d }}</td>
            <td><input type="range" v-model="iv.d" min="0" max="31" step="1">{{ iv.d }}</td>
            <td v-if="autoEv">{{ optStats.ev.d }}</td>
            <td v-else><input type="range" v-model="ev.d" min="0" max="252" step="4">{{ ev.d }}</td>
            <td v-if="autoEv">{{ optStats.n.d }}</td>
            <td v-else><input type="range" v-model="n.d" min="0.9" max="1.1" step="0.1">{{ n.d }}</td>
            <td>x <input type="number" v-model="bonus.d" min="0" max="2" step="0.1"></td>
            <td>
              {{ computedStatsAtLevel.d }}
              <span v-if="bonus.d != 1">({{ computedStatsAtLevel.withBonus.d }})</span>
            </td>
          </tr>
          <tr>
            <td>素早</td>
            <td>{{ stats.s }}</td>
            <td><input type="range" v-model="iv.s" min="0" max="31" step="1">{{ iv.s }}</td>
            <td><input type="range" v-model="ev.s" min="0" max="252" step="4">{{ ev.s }}</td>
            <td><input type="range" v-model="n.s" min="0.9" max="1.1" step="0.1">{{ n.s }}</td>
            <td>x <input type="number" v-model="bonus.s" min="0" max="2" step="0.1"></td>
            <td>
              {{ computedStatsAtLevel.s }}
              <span v-if="bonus.s != 1">({{ computedStatsAtLevel.withBonus.s }})</span>
            </td>
          </tr>
          <tr>
            <td>残り</td>
            <td></td>
            <td></td>
            <td v-if="autoEv">{{ 508 - ev.a - ev.c - ev.s }}</td>
            <td v-else>{{ 508 - ev.h - ev.a - ev.b - ev.c - ev.d - ev.s }}</td>
            <td></td>
            <td></td>
            <td></td>
          </tr>
        </table>

        <p>
          <label><input type="checkbox" v-model="autoEv"> 耐久を自動最適化</label>
          <span v-if="autoEv">
            (物理寄り
            <input type="range" min="0" max="1" step="0.01" v-model="autoEvRatio">
            {{ f(autoEvRatio * 100) + "%" }}
            特殊寄り)
          </span>
          <br />
          <small>※ 総合耐久指数 HBD/(B+D) が最大になる振り方を提案します</small>
        </p>

        <p>
          ワンパンライン：
          物理{{ f(computedStats.withBonus.h * computedStats.withBonus.b / 0.44) }} -
          特殊{{ f(computedStats.withBonus.h * computedStats.withBonus.d / 0.44) }}
        </p>
      </div>
    </div>

    <speed-list
        :show="tab === 'speed'"
        :computed-speed="computedStats.withBonus.s">
    </speed-list>

    <robustness-list
        category="物理"
        :show="tab === 'attack'"
        :types="types"
        :teratype="teratype"
        :computed-attack="computedStats.a"
        :item-bonus="bonus.a">
    </robustness-list>

    <robustness-list
        category="特殊"
        :show="tab === 'special-attack'"
        :types="types"
        :teratype="teratype"
        :computed-attack="computedStats.c"
        :item-bonus="bonus.c">
    </robustness-list>

  </div>

  <script type="text/x-template" id="speed-list">
    <div v-if="show" class="column">
      <h2>素早さ比較</h2>
      <p>
        フィルタ：
        <select v-model="filter">
          <option
              v-for="filter in filters"
              :value="filter.value">
            {{ filter.label }}
          </option>
        </select>
      </p>
      <table>
        <tr>
          <td>相手ポケモン</td>
          <td>実数値</td>
          <td>スカーフ</td>
        </tr>
        <tr v-for="poke in list">
          <td>{{ poke.label }}</td>
          <td :style="{ backgroundColor: colors[poke.value < computedSpeed] }">{{ poke.value }}</td>
          <td :style="{ backgroundColor: colors[poke.scarf < computedSpeed] }">{{ poke.scarf }}</td>
        </tr>
      </table>
    </div>
  </script>

  <script type="text/x-template" id="robustness-list">
    <div v-if="show" class="column">
      <h2>一括ダメージ計算（{{ category }}）</h2>
      <table>
        <tr>
          <td>技タイプ</td>
          <td>分類</td>
          <td>威力</td>
          <td>タイプ一致</td>
          <td>ランク上昇</td>
          <td>天候</td>
          <td>その他</td>
          <td>テラスタル</td>
        </tr>
        <tr>
          <td><input list="types" v-model="move.type"></td>
          <td>{{ category }}</td>
          <td><input type="number" v-model="move.strength" min="0" max="200" step="1"></td>
          <td>x {{ sameTypeBonus }}</td>
          <td>x <input type="number" v-model="move.bonuses.rank" min="0" max="2" step="0.5"></td>
          <td>x <input type="number" v-model="move.bonuses.weather" min="0" max="2" step="0.5"></td>
          <td>x <input type="number" v-model="move.bonuses.others" min="0" max="2" step="0.1"></td>
          <td><input type="checkbox" v-model="move.terastal" /></td>
        </tr>
      </table>
      <ul>
        <li>HBD ... 物理・特殊バランス良く振った個体 (HBD/(B+D) が最大)</li>
        <li>HB/HD ... 物理・特殊どちらかに全振りしている個体 (HB または HD が最大)</li>
      </ul>
      <p>
        フィルタ：
        <select v-model="filter">
          <option
              v-for="filter in filters"
              :value="filter.value">
            {{ filter.label }}
          </option>
        </select>
      </p>
      <table>
        <tr>
          <td>相手ポケモン</td>
          <td>ダメージ</td>
          <td>相性</td>
        </tr>
        <tr v-for="poke in list">
          <td>{{ poke.label }}</td>
          <td :style="{ backgroundImage: poke.gradient }">
            {{ r(poke.minDamageRatio * 100) }}〜{{ r(poke.maxDamageRatio * 100) }}%
          </td>
          <td>x {{ poke.effectiveness }}</td>
        </tr>
      </table>
    </div>
  </script>

  <script src="./data.js"></script>
  <script>
const f = Math.floor;
const r = Math.round;
const c = Math.ceil;

const colors = {
  "0": "rgba(0, 0, 0, 0.3)",
  "0.25": "rgba(0, 0, 255, 0.4)",
  "0.5": "rgba(0, 0, 255, 0.2)",
  "1": "transparent",
  "2": "rgba(255, 0, 0, 0.2)",
  "4": "rgba(255, 0, 0, 0.4)",
  "false": "rgba(255, 0, 0, 0.2)",
  "true": "rgba(0, 0, 255, 0.2)",
};

const hexPoints = (values, size) => (
  values.map((value, ix) => {
    if (value == null) return "";
    const angle = ((60 * ix) - 90) * Math.PI / 180;
    const val = ix === 0 ? value / 350 : value / 175;
    const x = Math.cos(angle) * val * (size / 2) + (size / 2);
    const y = Math.sin(angle) * val * (size / 2) + (size / 2);
    return `${x},${y}`;
  }).join(" ")
);

const numbifyStats = (stats) => ({
  h: Number(stats.h),
  a: Number(stats.a),
  b: Number(stats.b),
  c: Number(stats.c),
  d: Number(stats.d),
  s: Number(stats.s),
});

const bruteOptimizeHBD = ({ stats, iv, ev, n, bonus }, balance = 0.5) => {
  const remainingEv = 508 - ev.h - ev.a - ev.b - ev.c - ev.d - ev.s;
  const remainingN = n.a <= 1 && n.b <= 1 && n.c <= 1 && n.d <= 1 && n.s <= 1;
  const possibleNs = !remainingN ? [n] : [{ ...n, b: 1.1 }, { ...n, d: 1.1 }];

  const evaluate = ({ stats, iv, ev, n }) => {
    const h = Math.floor(Math.floor(stats.h + iv.h / 2 + ev.h / 8) + 60 * bonus.h);
    const b = Math.floor(
      Math.floor((Math.floor(stats.b + iv.b / 2 + ev.b / 8) + 5) * n.b) * bonus.b
    );
    const d = Math.floor(
      Math.floor((Math.floor(stats.d + iv.d / 2 + ev.d / 8) + 5) * n.d) * bonus.d
    );
    return { h, b, d, value: h * b * d / (2 * balance * b + (2 - 2 * balance) * d) };
  };

  let maxValue = evaluate({ stats, iv, ev, n });
  let maxEv = ev;
  let maxN = n;
  const limDh = Math.min(remainingEv, 252 - ev.d);
  for (n of possibleNs) {
    for (let dh = 0; dh <= limDh; dh += 4) {
      const limDb = Math.min(remainingEv - dh, 252 - ev.b);
      for (let db = 0; db <= limDb; db += 4) {
        const dd = remainingEv - dh - db;
        if (dh + db + dd <= remainingEv && ev.d + dd <= 252) {
          const newEv = { h: ev.h + dh, a: ev.a, b: ev.b + db, c: ev.c, d: ev.d + dd, s: ev.s };
          const value = evaluate({ stats, iv, n, ev: newEv });
          if (value.value > maxValue.value ||
              (value.value === maxValue.value && newEv.h > maxEv.h) ||
              (value.value === maxValue.value && newEv.b > maxEv.b)) {
            maxValue = value;
            maxEv = newEv;
            maxN = n;
          }
        }
      }
    }
  }

  return { n: maxN, ev: maxEv, value: maxValue };
};

const evaluateStats = ({ stats, ev, iv, n, bonus }, level) => {
  const baseStats = {
    h: f((stats.h * 2 + iv.h + f(ev.h / 4)) * level / 100),
    a: f((stats.a * 2 + iv.a + f(ev.a / 4)) * level / 100),
    b: f((stats.b * 2 + iv.b + f(ev.b / 4)) * level / 100),
    c: f((stats.c * 2 + iv.c + f(ev.c / 4)) * level / 100),
    d: f((stats.d * 2 + iv.d + f(ev.d / 4)) * level / 100),
    s: f((stats.s * 2 + iv.s + f(ev.s / 4)) * level / 100),
  };
  const computedStats = {
    h: baseStats.h + Number(level) + 10,
    a: f((baseStats.a + 5) * n.a),
    b: f((baseStats.b + 5) * n.b),
    c: f((baseStats.c + 5) * n.c),
    d: f((baseStats.d + 5) * n.d),
    s: f((baseStats.s + 5) * n.s),
  };
  return {
    ...computedStats,
    withBonus: {
      h: f(computedStats.h * bonus.h),
      a: f(computedStats.a * bonus.a),
      b: f(computedStats.b * bonus.b),
      c: f(computedStats.c * bonus.c),
      d: f(computedStats.d * bonus.d),
      s: f(computedStats.s * bonus.s),
    },
  };
};

const speedFilters = [{
  label: "ピックアップ",
  value: (po) => !!pickedupPokemons[po.name],
}, {
  label: "すべて",
  value: (po) => true,
}];

const SpeedList = Vue.component("speed-list", {
  template: "#speed-list",
  props: {
    show: { type: Boolean, required: true },
    computedSpeed: { type: Number, required: true },
  },
  data: () => ({
    filters: speedFilters,
    filter: speedFilters[0].value,
  }),
  computed: {
    list() {
      return pokemonNames.flatMap((name) => [{
        name,
        label: name + " 個体値0",
        value: pokemons[name].stats.s + 5,
        scarf: f((pokemons[name].stats.s + 5) * 1.5),
      }, {
        name,
        label: name + " 4振り",
        value: pokemons[name].stats.s + 21,
        scarf: f((pokemons[name].stats.s + 21) * 1.5),
      }, {
        name,
        label: name + " 252振り",
        value: pokemons[name].stats.s + 52,
        scarf: f((pokemons[name].stats.s + 52) * 1.5),
      }, {
        name,
        label: name + " 252振り＋補正",
        value: f((pokemons[name].stats.s + 52) * 1.1),
        scarf: f(f((pokemons[name].stats.s + 52) * 1.1) * 1.5),
      }]).sort((a, b) => b.value - a.value).filter(this.filter);
    },
  },
});

const robustnessFilters = [{
  label: "ピックアップ",
  value: (po) => !!pickedupPokemons[po.name] && po.effectiveness !== 0,
}, {
  label: "すべて (無効以外)",
  value: (po) => po.effectiveness !== 0,
}, {
  label: "等倍以上",
  value: (po) => po.effectiveness >= 1,
}, {
  label: "半減以下",
  value: (po) => po.effectiveness <= 0.5 && po.effectiveness !== 0,
}, {
  label: "抜群以上",
  value: (po) => po.effectiveness >= 2,
}, {
  label: "等倍",
  value: (po) => po.effectiveness === 1,
}];

const RobustnessList = Vue.component("robustness-list", {
  template: "#robustness-list",
  props: {
    show: { type: Boolean, required: true },
    category: { type: String, required: true },
    types: { type: Array, required: true },
    teratype: { type: String, required: true },
    computedAttack: { type: Number, required: true },
    itemBonus: { type: Number, required: true },
  },
  data: () => ({
    filters: robustnessFilters,
    filter: robustnessFilters[0].value,
    move: {
      terastal: false,
      category: "物理",
      type: "ノーマル",
      strength: 90,
      bonuses: { rank: 1, weather: 1, others: 1 },
    },
  }),
  computed: {
    sameTypeBonus() {
      if (this.move.terastal && this.types.includes(this.teratype)) {
        return this.types.includes(this.move.type) ? 2 : 1;
      } else if (this.move.terastal && this.move.type === this.teratype) {
        return 1.5;
      } else {
        return this.types.includes(this.move.type) ? 1.5 : 1;
      }
    },
    patterns() {
      return pokemonNames.flatMap((name) => {
        const { stats, types } = pokemons[name];
        const iv = { h: 31, a:31, b: 31, c: 31, d: 31, h: 31 };
        const ev508 = { h: 0, a: 0,   b: 0, c: 0, d: 0, s: 0 };
        const ev256 = { h: 0, a: 252, b: 0, c: 0, d: 0, s: 0 };
        const ev4   = { h: 0, a: 252, b: 0, c: 0, d: 0, s: 252 };
        const n   = { a: 1,   b: 1, c: 1, d: 1, s: 1 };
        const noN = { a: 1.1, b: 1, c: 1, d: 1, s: 1 };
        const bonus = { h: 1, a: 1, b: 1, c: 1, d: 1, s: 1 };
        const extreme = this.category === "物理" ? 0 : 1;
        const extremeTag = this.category === "物理" ? "HB" : "HD";
        return [{
          name,
          types: pokemons[name].types,
          tag: `４振り（${extremeTag}）`,
          ...bruteOptimizeHBD({ stats, iv, ev: ev4, n: noN, bonus }, extreme),
        }, {
          name,
          types: pokemons[name].types,
          tag: `２５６振り (${extremeTag})`,
          ...bruteOptimizeHBD({ stats, iv, ev: ev256, n: noN, bonus }, extreme),
        }, {
          name,
          types: pokemons[name].types,
          tag: "２５６振り（HBD）",
          ...bruteOptimizeHBD({ stats, iv, ev: ev256, n: noN, bonus }, 0.5),
        }, {
          name,
          types: pokemons[name].types,
          tag: `５０８振り＋補正（${extremeTag}）`,
          ...bruteOptimizeHBD({ stats, iv, ev: ev508, n: n, bonus }, extreme),
        }, {
          name,
          types: pokemons[name].types,
          tag: `５０８振り＋補正（HBD）`,
          ...bruteOptimizeHBD({ stats, iv, ev: ev508, n: n, bonus }, 0.5),
        }];
      });
    },
    list() {
      return this.patterns.map((p) => {
        const typeIsValid = types.includes(this.move.type);
        const eff = typeIsValid ? (
          p.types.reduce((l, r) => l * effectiveness[this.move.type][r], 1)
        ) : 1;
        const defence = this.category === "物理" ? p.value.b : p.value.d;
        const attack = f(this.computedAttack * this.move.bonuses.rank);
        const baseDamage = r(
          f(f(22 * this.move.strength * attack / defence) / 50 + 2) * this.move.bonuses.weather
        );
        const minBaseDamage = f(baseDamage * 0.85);
        const maxDamage = f(r(baseDamage * this.sameTypeBonus) * eff);
        const minDamage = f(r(minBaseDamage * this.sameTypeBonus) * eff);
        const maxDamageWithBonus = r(
          r(maxDamage * this.itemBonus) * this.move.bonuses.others
        );
        const minDamageWithBonus = r(
          r(minDamage * this.itemBonus) * this.move.bonuses.others
        );
        const minDamageRatio = minDamageWithBonus / p.value.h;
        const maxDamageRatio = maxDamageWithBonus / p.value.h;
        const gradient = (
          "linear-gradient(to right, " +
          "rgba(255, 0, 0, 0.2) 0%, " +
          "rgba(255, 0, 0, 0.2) " + (minDamageRatio * 100) + "%, " +
          "rgba(255, 0, 0, 0.1) " + (minDamageRatio * 100) + "%, " +
          "rgba(255, 0, 0, 0.1) " + (maxDamageRatio * 100) + "%, " +
          "transparent " + (maxDamageRatio * 100) + "%" +
          ")"
        );
        return {
          name: p.name,
          label: `${p.name} ${p.tag}`,
          hp: p.value.h,
          minDamage: minDamageWithBonus,
          maxDamage: maxDamageWithBonus,
          minDamageRatio,
          maxDamageRatio,
          effectiveness: eff,
          robustness: defence * p.value.h / eff,
          gradient,
        };
      }).filter(this.filter).sort((l, r) => r.robustness - l.robustness);
    },
  },
});

const vm = new Vue({
  el: "#app",
  data: () => ({
    pokemonNames,
    allTypes: types,
    pokemonName: "",
    pokemonNameError: true,
    level: 50,
    types: ["ノーマル"],
    teratype: "ノーマル",
    stats: { h: 0, a: 0, b: 0, c: 0, d: 0, s: 0 },
    iv: { h: 31, a: 31, b: 31, c: 31, d: 31, s: 31 },
    ev: { h: 0, a: 0, b: 0, c: 0, d: 0, s: 0 },
    n: { a: 1, b: 1, c: 1, d: 1, s: 1 },
    bonus: { h: 1, a: 1, b: 1, c: 1, d: 1, s: 1 },
    autoEv: true,
    autoEvRatio: 0.5,
    tab: "",
  }),
  watch: {
    pokemonName() {
      const pokemon = pokemons[this.pokemonName];
      if (pokemon) {
        this.pokemonNameError = false;
        this.level = 50;
        this.types = pokemon.types;
        this.teratype = pokemon.types[0];
        this.stats = pokemon.stats;
        this.iv = { h: 31, a: 31, b: 31, c: 31, d: 31, s: 31 };
        this.ev = { h: 0, a: 0, b: 0, c: 0, d: 0, s: 0 };
        this.n = { a: 1, b: 1, c: 1, d: 1, s: 1 };
        this.bonus = { h: 1, a: 1, b: 1, c: 1, d: 1, s: 1 };
      } else {
        this.pokemonNameError = true;
      }
    },
  },
  computed: {
    defEffectiveness() {
      return types.map((t) => this.types.reduce((l, r) => l * effectiveness[t][r], 1));
    },
    optStats() {
      if (this.autoEv) {
        return bruteOptimizeHBD({
          stats: this.stats,
          iv: numbifyStats(this.iv),
          ev: numbifyStats({ h: 0, a: this.ev.a, b: 0, c: this.ev.c, d: 0, s: this.ev.s }),
          n: numbifyStats(this.n),
          bonus: numbifyStats(this.bonus),
        }, this.autoEvRatio);
      } else {
        return { n: this.n, ev: this.ev };
      }
    },
    computedStats() {
      return evaluateStats({
        stats: numbifyStats(this.stats),
        iv: numbifyStats(this.iv),
        ev: numbifyStats(this.optStats.ev),
        n: numbifyStats(this.optStats.n),
        bonus: numbifyStats(this.bonus),
      }, 50);
    },
    computedStatsAtLevel() {
      return evaluateStats({
        stats: numbifyStats(this.stats),
        iv: numbifyStats(this.iv),
        ev: numbifyStats(this.optStats.ev),
        n: numbifyStats(this.optStats.n),
        bonus: numbifyStats(this.bonus),
      }, this.level);
    },
    chartPolygons() {
      const { h, a, b, c, d, s } = this.stats;
      const { h: ch, a: ca, b: cb, c: cc, d: cd, s: cs } = this.computedStats;
      const { h: wh, a: wa, b: wb, c: wc, d: wd, s: ws } = this.computedStats.withBonus;
      return [{
        points: hexPoints([350, 175, 175, 175, 175, 175], 300),
        fill: "rgba(0, 0, 0, 0.05)",
      }, {
        points: hexPoints([300, 150, 150, 150, 150, 150], 300),
        stroke: "rgba(255, 255, 255, 1)",
      }, {
        points: hexPoints([200, 100, 100, 100, 100, 100], 300),
        stroke: "rgba(255, 255, 255, 1)",
      },  {
        points: hexPoints([f(h+107), f(a+52), f(b+52), f(s+52), f(d+52), f(c+52),], 300),
        stroke: "rgba(0, 0, 0, 0.25)",
      }, {
        points: hexPoints([f(h+75), f(a+20), f(b+20), f(s+20), f(d+20), f(c+20)], 300),
        stroke: "rgba(0, 0, 0, 0.25)",
      }, {
        points: hexPoints([null, wa, null, ws, null, wc], 300),
        fill: "rgba(255, 0, 0, 0.25)",
        stroke: "rgba(255, 0, 0, 0.5)",
      }, {
        points: hexPoints([null, ca, null, cs, null, cc], 300),
        fill: "rgba(255, 0, 0, 0.5)",
      }, {
        points: hexPoints([wh, null, wb, null, wd], 300),
        fill: "rgba(0, 0, 255, 0.167)",
        stroke: "rgba(0, 0, 255, 0.334)",
      }, {
        points: hexPoints([ch, null, cb, null, cd], 300),
        fill: "rgba(0, 0, 255, 0.334)",
      }];
    },
  },
});
  </script>
</body>
